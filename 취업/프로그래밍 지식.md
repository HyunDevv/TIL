# 프로그래밍 지식
## 개발 상식
### 동기와 비동기

- 동기 - 작업을 순차대로 한다, 설계가 간단하지만 결과가 주어질 때까지 아무것도 못하고 대기해야 한다
- 비동기 - 병렬적으로 동시에 일을 처리한다, 효율적이지만 복잡하다, 자원을 효율적으로 사용할 수 있다 ex) NODE.JS

### 객체 지향 프로그래밍이란?

- 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것
- 객체를 기본으로 기능을 제공하는 것
  
- 장점
  - 코드의 **재사용성**이 좋다 - 계속 사용되는 로직을 라이브러리로 만들어두면 계속 사용할 수 있으며 그 신뢰성을 확보 할 수 있다.
  - 라이브러리가 제공하는 기능들을 사용할 수 있어 **생산성**이 좋다.
  - 객체 단위로 코드가 나뉘어져 디버깅이 쉽고 **유지보수**에 용이하다.
  - 데이터 모델링 시 객체와 매핑하는 것이 수월하기 때문에 **요구사항**을 **명확**하게 파악하고 프로그래밍 할 수 있다

- 단점
  - 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 **시스템에 많은 overhead**(어떤 작업을 처리할 때 들어가는 CPU타임이나 메모리 용량)가 발생하게 된다. - 하지만 하드웨어의 발전으로 보완, 함수형 프로그래밍 주목(객체가 상태를 갖는 것)

### RESTful API

> REST는 Representational State Transfer의 약자이다

- 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식
- 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴



어떠한 장점이 존재하는가?

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

단점은 뭐가 있을까?

1. 사용할 수 있는 메소드가 4 가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.



#### REST API 설계 시 중요한 2가지

1. URI는 정보의 자원을 표현해야 한다.

2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.



### TDD란 무엇인가

- 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다.



### 함수형 프로그래밍

2가지의 큰 특징

1. immutable data : **객체가 가지고 있는 값을 변경할 수 없는 객체**를 의미하며 변경될 경우, 새로운 객체를 생성하고 변경된 값을 주입하여 반환해야 한다.
2.  first class citizen으로서의 function
   - **변수나 데이터 구조안에 함수를 담을 수 있어서** 함수의 파라미터로 전달할 수 있고, 함수의 변환값으로 사용할 수 있다.
   - 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
   - 함수를 리터럴로 바로 정의할 수 있다.



### MVC 패턴

> Model + View + Controller를 합친 용어

<img src="md-images/image-20201230001409651.png" alt="image-20201230001409651" style="zoom: 80%;" />

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분
- View : 사용자에게 보여지는 UI
- Controller : 사용자의 입력(Action)을 받고 처리하는 부분



- 단순하고 보편적이지만 View와 Model의 의존성이 높아 어플리케이션이 커질수록 복잡해지고 유지보수가 어려울 수 있다



### MVP 패턴

> Model + View + Presenter를 합친 용어

![image-20210106152512387](md-images/image-20210106152512387.png)

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분입니다.

- View : 사용자에서 보여지는 UI 부분입니다.

- Presenter : View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분입니다. View와 Model을 붙여주는 역할을 합니다.



### MVVM 패턴

> Model + View + View Model을 합친 용어

![image-20210106152526056](md-images/image-20210106152526056.png)

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분입니다.

- View : 사용자에서 보여지는 UI 부분입니다.

- View Model : View를 표현하기 위해 만든 View를 위한 Model입니다. View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분입니다.



-  동작

MVVM 패턴의 동작 순서는 아래와 같습니다.

1. 사용자의 Action들은 View를 통해 들어오게 됩니다.
2. View에 Action이 들어오면, Command 패턴으로 View Model에 Action을 전달합니다.
3. View Model은 Model에게 데이터를 요청합니다.
4. Model은 View Model에게 요청받은 데이터를 응답합니다.
5. View Model은 응답 받은 데이터를 가공하여 저장합니다.
6. View는 View Model과 Data Binding하여 화면을 나타냅니다.

-  특징

MVVM 패턴은 [Command 패턴](https://ko.wikipedia.org/wiki/커맨드_패턴)과 [Data Binding](https://en.wikipedia.org/wiki/Data_binding) 두 가지 패턴을 사용하여 구현되었습니다.

Command 패턴과 Data Binding을 이용하여 View와 View Model 사이의 의존성을 없앴습니다.

View Model과 View는 1:n 관계입니다.

- 장점

MVVM 패턴은 View와 Model 사이의 의존성이 없습니다. 또한 Command 패턴과 Data Binding을 사용하여 View와 View Model 사이의 의존성 또한 없앤 디자인패턴입니다. 각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있습니다.

- 단점

MVVM 패턴의 단점은 View Model의 설계가 쉽지 않다는 점입니다.



### 라이브러리와 프레임워크

- 라이브러리 : 내가 필요할 때 부른다 (ex. jquery)
- 프레임워크 : 내가 프레임 워크의 규칙을 따른다, 프레임워크가 나를 부른다(ex. spring)
  



---

## CS

### Array와 Linked List

- Array  : 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 `인덱스`(index)로 해당 원소(element)에 접근할 수 있다. Array 자료구조에서 추가,삭제 기능에 대한 time complexity 의 worst case 는 O(n)이 된다.
- Linked List : 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1) 만에 해결할 수 있는 것이다. 하지만 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생하게 된다.

### Stack과  Queue

- Stack : 선형 자료구조의 일종으로 `Last In First Out (LIFO)`. 즉, 나중에 들어간 원소가 먼저 나온다.
- Queue : 선형 자료구조의 일종으로 `First In First Out (FIFO)`. 즉, 먼저 들어간 놈이 먼저 나온다.



### Tree

- 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다.

 ### Heap

![image-20210202223740201](md-images/image-20210202223740201.png)

### Hash

- 데이터를 유지관리하는 자료구조
- 인덱스,키 / 해시값,벨류 
- 특정 값을 찾는데 key로 접근하기 때문에 속도가 빠르다
- 하지만 어설픈 해쉬함수를 이용하면 동일한 키에 여러 데이터가 존재할 수 있다 이를 충돌이라한다
- 충돌을 해결하기 위해 Chaining(키의 벨류값 뒤에 붙이기)과 Linear Probing / Resizing (다음키에 붙이기 / 자리가 없으면 표 늘리기)을 사용한다



### Graph

#### 깊이 우선 탐색 (Depth First Search: DFS)

재귀함수 활용

#### 너비 우선 탐색 (Breadth First Search: BFS)

큐 사용

https://www.youtube.com/watch?v=7C9RgOcvkvo



## 네트워크

### GET과 POST

> HTTP 프로토콜을 이용해서 서버에 요청하는 방식

- GET : 데이터가 HTTP Message의 Header 부분의 url에 담겨서 전송된다. / 서버에서 데이터를 가져온다
  데이터 크기가 제한적이고 보안에 취약하다
- POST : 데이터가 HTTP Message의 Body 부분에 담겨서 전송된다. / 서버의 값이나 상태를 변경,추가한다
  데이터 크기가 GET 보다 크고 보안에 다 낫다



### TCP와 UDP

- UDP : 비연결형 프로토콜이다. 신뢰성, 순차적 전달X

- TCP : 소캣을 생성해 종단간에 바이트 스트림을 전송 / 연결설정은 3-way-handshake를 사용

  

### HTTP 통신의 문제점

- 도청 가능
- 위장 가능
- 변조 가능

-> 해결법 : 증명서를 사용하는 SSL(Secure Socket Layer)을 조합한 HTTPS 사용



### 웹소켓

서버와 클라이언트 간에 소켓 커넥션을 유지해서 언제든 양방향 통신이 가능하도록 하는 기술

소켓과 웹소켓의 차이 : 웹소켓은 HTTP레이어에서 작동하는 소켓으로  TCP/IP 소켓의 레이어가 다르다



---

## OS

### 프로세스와 스레드

- 프로세스 : 실행중인 프로그램 / 컴퓨터의 자원을 분할해 사용한다
- 스레드 : 프로세스의 실행 단위 / 프로세스마다 주어진 자원을 함께 사용한다

### 멀티 스레드 vs 멀티 프로세스

**멀티 스레드는** 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, **오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제**를 안고 있다. 반면 **멀티 프로세스** 방식은 **하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고** 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 **많은 메모리 공간과 CPU 시간을 차지한다는 단점**이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

### 캐시

캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.



## 데이터베이스

### 데이터베이스 사용이유

데이터의 독립성, 중복성 해결, 무결성

### 인덱스

DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능.

### 정규화

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업

- 제 1 정규형
  릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있을 때
- 제 2 정규형
  릴레이션이 제 1정규형에 속하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때
- 제 3 정규형
  릴레이션이 제 2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않을 때

### 트랜잭션

- **작업의 완전성을 보장**해주는 것
- 작업의 **논리적 단위**로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다



### 제약조건

1. 도메인 무결성 : 속성이 정의되어 있는 **영역을 벗어나지 않도록 규정**하는 것
   (CHECK, DEFAULT, NOT NULL..)
2. 개체 무결성 : 하나의 테이블에 **중복된 행이 존재하지 않도록 규정**하는 것
   (UNIQUE, PRIMARY KEY..)
3. 참조 무결성 : **행을 입력, 수정, 삭제할 때 연관되는 다른 테이블과의 데이터가 정확하게 유지되도록 규정**하는 것
   (FOREIGN KEY..)

---

## Design Pattern

### Singleton

`Singleton pattern(싱글턴 패턴)`이란 **애플리케이션에서 인스턴스를 하나만 만들어 사용하기 위한 패턴**이다. 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등의 경우, 인스턴스를 여러 개 만들게 되면 자원을 낭비하게 되거나 버그를 발생시킬 수 있으므로 오직 하나만 생성하고 그 인스턴스를 사용하도록 하는 것이 이 패턴의 목적이다.

---

## JAVA

### JVM

자바가상머신으로 **운영체제에 독립적으로 사용**할 수 있고 **자동으로 메모리 관리**를 하여 안정적인 프로그래밍 가능

JVM의 메모리영역(Runtime Data Area)

- Method Area (모든 스레드가 공유) : JVM이 시작될 때 생성되는 공간으로 바이트코드가 이 영역에 저장
  (클래스 정보, 변수 정보, static으로 선언한 변수가 저장)

  <img src="md-images/image-20210120153017900.png" alt="image-20210120153017900" style="zoom: 50%;" />

- Heap (모든 스레드가 공유) : 동적으로 생성된 객체가 저장되는 영역, GC의 대상이 되는 공간
  new연산으로 생성 된 인스턴스 변수, 클래스의 객체, 배열 등

- Stack (스레드 마다 생성) : 지역변수나 메서드의 매게변수, 임시적으로 사용되는 변수, 메서드의 정보가 저장

- PC Register (스레드 마다 생성) : 스레드가 시작될 때 생성되며, 현재 수행중인 JVM 명령어 주소를 저장하는 공간입니다. 스레드가 어떤 부분을 어떤 명령어로 수행할지를 저장하는 공간.

- Native Method Stack (스레드 마다 생성) : JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간
  JNI를 통해 호출하는 C/C++등의 코드를 수행하기 위한 공간

### 가비지 컬렉션

**사용하지 않는 객체를 메모리에서 삭제하는 작업**을 Gargabe Collection(GC)라고 부르며 JVM에서 GC를 수행합니다. 기본적으로 JVM의 메모리는 총 5가지 영역(ex. 클래스, 스택, 힙, 네이티브 메서드, PC)으로 나뉘는데, GC는 힙 메모리만 다룹니다. 



### static

<img src="md-images/image-20210120151124407.png" alt="image-20210120151124407" style="zoom: 67%;" />



### Collection

> **데이터의 집합을 의미하며 Java Collections Framework는 이러한 데이터, 자료구조의 컬렉션과 이를 구현하는 클래스를 정의하는 인터페이스를 제공한다.**

Java Collection 에는 `List`, `Map`, `Set` 인터페이스를 기준으로 여러 구현체가 존재한다. 이에 더해 `Stack`과 `Queue` 인터페이스도 존재한다. 왜 이러한 Collection 을 사용하는 것일까? 그 이유는 다수의 Data 를 다루는데 표준화된 클래스들을 제공해주기 때문에 DataStructure 를 직접 구현하지 않고 편하게 사용할 수 있기 때문이다. 또한 배열과 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로, 상황에 따라 객체의 수를 동적으로 정할 수 있다. 이는 프로그램의 공간적인 효율성 또한 높여준다.

![image-20210201135908949](md-images/image-20210201135908949.png)



###  Annotation

주석처럼 코드에 달아 **클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있는 인터페이스**이다



### Generic

제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다. 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, **컴파일 과정에서 타입체크를 해주는 기능**이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여준다. 자연스럽게 코드도 더 간결해진다. 예를 들면, Collection 에 특정 객체만 추가될 수 있도록, 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 하는 것이 제네릭이다. 이로 인한 장점은 collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없어진다. 또한 api 를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.



### 트랜잭션 처리

ACID(원일고지)를 유지하는것

- Atomicity : 원자성 - All or Noting
- Consistency : 일관성 - 트랙잭션 작업이 끝난 후에도 일관성 있는 DB상태를 유지해야한다
- Isolation : 고립성 - 트랜잭션 작업 중 다른 트랜잭션에 영향을 줘서도 받아서도 안된다
- Durability : 지속성 - 데이터 조작 완료 후 영구적이 되어 결과를 잃지 않는다.



### 오버라이드와 오버로드

- 오버라이딩 : 상위 클래스 혹은 인터페이스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것
  
- 오버로딩 : 메소드의 이름과 return 타입은 동일하지만, 매개변수만 다른 메소드를 만드는 것

  

  

###  SQLMapper

- SQL ⬅ SQLMapper ➡ Object 필드
- **SQL 문장으로 직접 데이터베이스 데이터를 다룬다.**
- SQL을 직접 작성해줘야 한다.
- **Mybatis**, **JdbcTemplates**(spring)

###  ORM

- 데이터베이스 데이터 ⬅ ORM ➡ Object 필드

- **객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.**

- 객체와 관계형 데이터베이스의 데이터를 자동으로 맵핑 시켜준다.
  
  - SQL Query가 아닌 직관적인 코드(메서드)로 데이터 조작
  
- **JPA**, **Hibernate**

  

  ### 🍌 MyBatis vs Hibernate

  #### 🍓 MyBatis

  - 반복적인 JDBC 프로그래밍을 단순화하기 위해 iBatis라는 이름으로 출발
    - 이후에 아파치 소프트웨어 재단에서 구글 코드(Google Code)로 이사하면서 MyBatis라는 이름으로 바뀜
  - **개발과 유지보수가 쉽도록 소스 코드에 박혀있는** **SQL을 별도의 파일로 분리**

  #### 🍓 Hibernate

  - JPA의 실제 구현체
  - HQL(Hibernate Query Language)라는 객체 질의어를 제공
    - SQL을 몰라도 되기 때문에 개발자의 부담이 줄어든다.
    - 실행 시에 DBMS에 맞추어 SQL 문을 자동 생성하기 때문에 특정 DBMS에 종속되지 않는다.
  - 데이터베이스의 정규화(normalized)가 잘돼 있어야 한다.
    - 테이블을 객체와 연결하기 쉽고, 객체를 통해 테이블의 데이터를 다루기가 쉽다.
  - 데이터베이스의 특징에 맞추어 최적화를 할 수 없다.
    - 데이터베이스 마다 실행 성능을 높이고 데이터 처리를 쉽게 해주는 특별한 기능을 각각 가지고 있다.
    - 이런 기능을 활용할 수 있도록 전용 SQL을 제공하지만, ORM에서는 SQL을 직접 작성하지 않기 때문에 최적화가 쉽지 않다.

  #### 🍓 왜 JPA, Hibernate를 쓰는가? MyBatis와는 뭐가 다른가? (면접 질문)

  사실 최근 5년간 사용률은 **전세계적으로는 JPA > MyBatis**, **국내에서는 JPA < MyBatis** 이다. 위에서 정리했듯이, ORM(JPA), SQL Mapper(MyBatis)가 더 좋다, 나쁘다를 확언하기가 어렵다.

  각각의 장,단점이 있고, **JPA의 사용률이 높아지는 이유는 복잡한 데이터를 추출하는 업무보다는 비즈니스 로직에 집중하고, 수정하는 업무가 주이기 때문**인 것 같다.

  무작정 생산성이 빠르다, SQL을 신경쓰지 않아도 된다 등 장점이 많아서 사용한다기 보다는 ”**개발하고 있는 서비스에 어떤 것이 적합한가? 왜 써야만 할까?**“와 같은 사상적인 면에서 고민하고 결정하는 것이 맞는 것 같다.

  결론은 둘 다 알아두는 것이 좋다..!



---

## Spring

### IoC

개발자가 프로그램의 흐름(코드)를 제어하는게 아니라 스프링 프레임워크가 주도하는 것

객체의 생성부터 생명주기 관리를 컨테이너가 도맡는다

### DI

객체간의 의존성을 자신이 아닌 외부에서 주입하는 개념이다

### Spring Boot

Spring Boot는 Spring를 사용하기 위한 설정의 많은 부분을 자동화하여 사용자가 편하게 Spring을 활용할 수 있도록 돕는다.

**해결하고자 하는것**
a) Auto Configuration 자동 실행
b) 쉬운 의존성 관리
c) 내장 서버

## 







---

## 알고리즘

### 정렬

선택정렬

<img src="md-images/image-20210117154358059.png" alt="image-20210117154358059" style="zoom: 33%;" />

<img src="md-images/image-20210117154434834.png" alt="image-20210117154434834" style="zoom:33%;" />

삽입정렬

![image-20210117154552981](md-images/image-20210117154552981.png)

![image-20210117154659665](md-images/image-20210117154659665.png)

퀵정렬

 ![image-20210117170420245](md-images/image-20210117170420245.png)

![image-20210117170500820](md-images/image-20210117170500820.png)

![image-20210118172402299](md-images/image-20210118172402299.png)

![image-20210118172332425](md-images/image-20210118172332425.png)

정렬 알고리즘 비교하기

![image-20210118172447123](md-images/image-20210118172447123.png)

### 탐색

이진탐색

![image-20210118203855677](md-images/image-20210118203855677.png)

![image-20210118205713090](md-images/image-20210118205713090.png)

![image-20210118213656874](md-images/image-20210118213656874.png)

값이 특정 번위에 속하는 데이터 개수를 파이썬 이진 탐색 라이브러리를 이용하여 구하기

![image-20210118213933405](md-images/image-20210118213933405.png)

파라메트릭 서치 -> 이진 탐색이용

떡볶이 문제

![image-20210118220232181](md-images/image-20210118220232181.png)

![image-20210118220253921](md-images/image-20210118220253921.png)

### 다이나믹 프로그래밍

피보나치 수열 - 재귀함수로 하면 시간이 오래걸림

![image-20210119143205104](md-images/image-20210119143205104.png)

![image-20210119143807959](md-images/image-20210119143807959.png)

![image-20210119144300297](md-images/image-20210119144300297.png)



### 아호 코라식 알고리즘

 **아호 코라식 알고리즘**(Aho–Corasick string matching algorithm)은 Alfred V. Aho와 Margaret J. Corasick이 고안한 [문자열 검색 알고리즘](https://ko.wikipedia.org/wiki/문자열_검색_알고리즘)(매칭 알고리즘)이다.



### Union-Find 자료구조

**Union-Find** 자료구조는 상호 배타적 집합, 서로소 집합 (Disjoint Set)을 표현하기 위한 자료구조이다.




### 외판원 순회(TSP: Traveling Salesperson Problem)

**외판원 순회(TSP: Traveling Salesperson Problem)**란 도시들이 있고 특정 도시에서 도시로 이동할 때 드는 비용이 주어졌을 때 불특정한 도시에서 출발해서 모든 도시를 돌고 다시 출발 도시로 돌아왔을 때 드는 최소 비용을 구하는 문제입니다.



---



## 안드로이드

---

- MVVM 패턴이란 무엇인가?
  모델, 뷰 , 뷰모델을 사용하고 요청을 받아 처리하는 부분과 보여주는 부분을 나누어 의존성을 낮추고 모듈화가 가능한 개발패턴입니다.

- 안드로이드 액티비티 생명주기

  onCreate - onStart - onResume - onPause - onStop - on Destroy

  ​                                                                                    ㄴonRestart - onStart

  

  ---

  프로젝트 관련 질문

  - 안드로이드 개발준비 : 스마트폰 개발자 옵션 활성화, USB디버깅 활성화, JDK설치, USB드라이버설치 등
  - 안드로이드 특징 : 오픈소스, 리눅스, 자바, ART라는 런타임이 탑재
    (ART : [안드로이드](https://namu.wiki/w/안드로이드(운영체제))에서 사용되던 기존의 [달빅](https://namu.wiki/w/달빅)VM의 한계점을 해결하기 위해서 [구글](https://namu.wiki/w/구글)에서 새로 개발한 런타임(실행환경))
  - DP를 사용해 다양한 디바이스 크기에 대응했다 글자는 SP사용

  

- Android 4 Component

- Activity : Base, UI / **UI화면을 담당한다**
- Service : Background Process / **백그라운드에서 실행되는 프로세스**
- Broadcast Receiver : (OS정보와 같은) Broadcast 내용을 받는다 / **안드로이드에서 다양한 이벤트와 정보를 받아 반응하는 컴포넌트**
- Content Provider :  **App Data 공유** (ex. 갤러리의 사진, 주소록의 전화번호를 가져온다, T전화기)



- 안드로이드 생명주기

<img src="md-images/image-20210107143710344.png" alt="image-20210107143710344" style="zoom:67%;" />

- intent의 역할 : 컴포넌트 간에 작업 수행을 위한 정보를 전달하는 역할 / 액티비티 간 화면전환, 서비스 시작, 브로드캐스트 전달 등에 사용
- SharedPreferences : 간단한 데이터를 파일로 저장
- Fragment : 하나의 액티비티에서 여러개의 화면을 갖고 싶을 때 사용한다

