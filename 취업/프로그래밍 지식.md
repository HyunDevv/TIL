# 프로그래밍 지식
## 개발 상식
### 동기와 비동기

- 동기 - 작업을 순차대로 한다, 설계가 간단하지만 결과가 주어질 때까지 아무것도 못하고 대기해야 한다
- 비동기 - 병렬적으로 동시에 일을 처리한다, 효율적이지만 복잡하다, 자원을 효율적으로 사용할 수 있다 ex) NODE.JS

### 객체 지향 프로그래밍이란?

- 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것
- 객체를 기본으로 기능을 제공하는 것
  
- 장점
  - 코드의 **재사용성**이 좋다 - 계속 사용되는 로직을 라이브러리로 만들어두면 계속 사용할 수 있으며 그 신뢰성을 확보 할 수 있다.
  - 라이브러리가 제공하는 기능들을 사용할 수 있어 **생산성**이 좋다.
  - 객체 단위로 코드가 나뉘어져 디버깅이 쉽고 **유지보수**에 용이하다.
  - 데이터 모델링 시 객체와 매핑하는 것이 수월하기 때문에 **요구사항**을 **명확**하게 파악하고 프로그래밍 할 수 있다

- 단점
  - 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 **시스템에 많은 overhead**(어떤 작업을 처리할 때 들어가는 CPU타임이나 메모리 용량)가 발생하게 된다. - 하지만 하드웨어의 발전으로 보완, 함수형 프로그래밍 주목(객체가 상태를 갖는 것)

### RESTful API

> REST는 Representational State Transfer의 약자이다

- 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식
- 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴



어떠한 장점이 존재하는가?

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

단점은 뭐가 있을까?

1. 사용할 수 있는 메소드가 4 가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.



#### REST API 설계 시 중요한 2가지

1. URI는 정보의 자원을 표현해야 한다.

2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.



### TDD란 무엇인가

- 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다.



### 함수형 프로그래밍

2가지의 큰 특징

1. immutable data : **객체가 가지고 있는 값을 변경할 수 없는 객체**를 의미하며 변경될 경우, 새로운 객체를 생성하고 변경된 값을 주입하여 반환해야 한다.
2.  first class citizen으로서의 function
   - **변수나 데이터 구조안에 함수를 담을 수 있어서** 함수의 파라미터로 전달할 수 있고, 함수의 변환값으로 사용할 수 있다.
   - 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
   - 함수를 리터럴로 바로 정의할 수 있다.



### MVC 패턴

> Model + View + Controller를 합친 용어

<img src="md-images/image-20201230001409651.png" alt="image-20201230001409651" style="zoom: 80%;" />

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분
- View : 사용자에게 보여지는 UI
- Controller : 사용자의 입력(Action)을 받고 처리하는 부분



- 단순하고 보편적이지만 View와 Model의 의존성이 높아 어플리케이션이 커질수록 복잡해지고 유지보수가 어려울 수 있다



### MVP 패턴

> Model + View + Presenter를 합친 용어

![image-20210106152512387](md-images/image-20210106152512387.png)

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분입니다.

- View : 사용자에서 보여지는 UI 부분입니다.

- Presenter : View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분입니다. View와 Model을 붙여주는 역할을 합니다.



### MVVM 패턴

> Model + View + View Model을 합친 용어

![image-20210106152526056](md-images/image-20210106152526056.png)

- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분입니다.

- View : 사용자에서 보여지는 UI 부분입니다.

- View Model : View를 표현하기 위해 만든 View를 위한 Model입니다. View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분입니다.



-  동작

MVVM 패턴의 동작 순서는 아래와 같습니다.

1. 사용자의 Action들은 View를 통해 들어오게 됩니다.
2. View에 Action이 들어오면, Command 패턴으로 View Model에 Action을 전달합니다.
3. View Model은 Model에게 데이터를 요청합니다.
4. Model은 View Model에게 요청받은 데이터를 응답합니다.
5. View Model은 응답 받은 데이터를 가공하여 저장합니다.
6. View는 View Model과 Data Binding하여 화면을 나타냅니다.

-  특징

MVVM 패턴은 [Command 패턴](https://ko.wikipedia.org/wiki/커맨드_패턴)과 [Data Binding](https://en.wikipedia.org/wiki/Data_binding) 두 가지 패턴을 사용하여 구현되었습니다.

Command 패턴과 Data Binding을 이용하여 View와 View Model 사이의 의존성을 없앴습니다.

View Model과 View는 1:n 관계입니다.

- 장점

MVVM 패턴은 View와 Model 사이의 의존성이 없습니다. 또한 Command 패턴과 Data Binding을 사용하여 View와 View Model 사이의 의존성 또한 없앤 디자인패턴입니다. 각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있습니다.

- 단점

MVVM 패턴의 단점은 View Model의 설계가 쉽지 않다는 점입니다.



## CS

### Array와 Linked List

- Array  : 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 `인덱스`(index)로 해당 원소(element)에 접근할 수 있다. Array 자료구조에서 추가,삭제 기능에 대한 time complexity 의 worst case 는 O(n)이 된다.
- Linked List : 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1) 만에 해결할 수 있는 것이다. 하지만 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생하게 된다.

### Stack과  Queue

- Stack : 선형 자료구조의 일종으로 `Last In First Out (LIFO)`. 즉, 나중에 들어간 원소가 먼저 나온다.
- Queue : 선형 자료구조의 일종으로 `First In First Out (FIFO)`. 즉, 먼저 들어간 놈이 먼저 나온다.



### Tree

- 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다.



### Hash

- 데이터를 유지관리하는 자료구조
- 인덱스,키 / 해시값,벨류 
- 특정 값을 찾는데 key로 접근하기 때문에 속도가 빠르다
- 하지만 어설픈 해쉬함수를 이용하면 동일한 키에 여러 데이터가 존재할 수 있다 이를 충돌이라한다
- 충돌을 해결하기 위해 Chaining(키의 벨류값 뒤에 붙이기)과 Linear Probing / Resizing (다음키에 붙이기 / 자리가 없으면 표 늘리기)을 사용한다



### Graph

#### 깊이 우선 탐색 (Depth First Search: DFS)

재귀함수 활용

#### 너비 우선 탐색 (Breadth First Search: BFS)

큐 사용

https://www.youtube.com/watch?v=7C9RgOcvkvo



## 네트워크

### GET과 POST

> HTTP 프로토콜을 이용해서 서버에 요청하는 방식

- GET : 데이터가 HTTP Message의 Header 부분의 url에 담겨서 전송된다. / 서버에서 데이터를 가져온다
  데이터 크기가 제한적이고 보안에 취약하다
- POST : 데이터가 HTTP Message의 Body 부분에 담겨서 전송된다. / 서버의 값이나 상태를 변경,추가한다
  데이터 크기가 GET 보다 크고 보안에 다 낫다



### TCP와 UDP

- UDP : 비연결형 프로토콜이다. 신뢰성, 순차적 전달X

- TCP : 소캣을 생성해 종단간에 바이트 스트림을 전송 / 연결설정은 3-way-handshake를 사용

  

### HTTP 통신의 문제점

- 도청 가능
- 위장 가능
- 변조 가능

-> 해결법 : 증명서를 사용하는 SSL(Secure Socket Layer)을 조합한 HTTPS 사용





## OS

### 프로세스와 스레드

- 프로세스 : 실행중인 프로그램 / 컴퓨터의 자원을 분할해 사용한다
- 스레드 : 프로세스의 실행 단위 / 프로세스마다 주어진 자원을 함께 사용한다

### 멀티 스레드 vs 멀티 프로세스

**멀티 스레드는** 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, **오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제**를 안고 있다. 반면 **멀티 프로세스** 방식은 **하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고** 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 **많은 메모리 공간과 CPU 시간을 차지한다는 단점**이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

### 캐시

캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.



## 데이터베이스

### 데이터베이스 사용이유

데이터의 독립성, 중복성 해결, 무결성

### 인덱스

DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능.

### 정규화

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업

- 제 1 정규형
  릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있을 때
- 제 2 정규형
  릴레이션이 제 1정규형에 속하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때
- 제 3 정규형
  릴레이션이 제 2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않을 때

### 트랜잭션

- **작업의 완전성을 보장**해주는 것
- 작업의 **논리적 단위**로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다

---

## Design Pattern

### Singleton

`Singleton pattern(싱글턴 패턴)`이란 **애플리케이션에서 인스턴스를 하나만 만들어 사용하기 위한 패턴**이다. 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등의 경우, 인스턴스를 여러 개 만들게 되면 자원을 낭비하게 되거나 버그를 발생시킬 수 있으므로 오직 하나만 생성하고 그 인스턴스를 사용하도록 하는 것이 이 패턴의 목적이다.

---

## JAVA

### JVM

자바가상머신으로 **운영체제에 독립적으로 사용**할 수 있고 **자동으로 메모리 관리**를 하여 안정적인 프로그래밍 가능

JVM의 메모리영역(Runtime Data Area)

- Method Area (모든 스레드가 공유) : JVM이 시작될 때 생성되는 공간으로 바이트코드가 이 영역에 저장
  (클래스 정보, 변수 정보, static으로 선언한 변수가 저장)

  <img src="md-images/image-20210120153017900.png" alt="image-20210120153017900" style="zoom: 50%;" />

- Heap (모든 스레드가 공유) : 동적으로 생성된 객체가 저장되는 영역, GC의 대상이 되는 공간
  new연산으로 생성 된 인스턴스 변수, 클래스의 객체, 배열 등

- Stack (스레드 마다 생성) : 지역변수나 메서드의 매게변수, 임시적으로 사용되는 변수, 메서드의 정보가 저장

- PC Register (스레드 마다 생성) : 스레드가 시작될 때 생성되며, 현재 수행중인 JVM 명령어 주소를 저장하는 공간입니다. 스레드가 어떤 부분을 어떤 명령어로 수행할지를 저장하는 공간.

- Native Method Stack (스레드 마다 생성) : JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간
  JNI를 통해 호출하는 C/C++등의 코드를 수행하기 위한 공간

### 가비지 컬렉션

사용하지 않는 객체를 메모리에서 삭제하는 작업을 Gargabe Collection(GC)라고 부르며 JVM에서 GC를 수행합니다. 기본적으로 JVM의 메모리는 총 5가지 영역(ex. 클래스, 스택, 힙, 네이티브 메서드, PC)으로 나뉘는데, GC는 힙 메모리만 다룹니다. 



### static

<img src="md-images/image-20210120151124407.png" alt="image-20210120151124407" style="zoom:50%;" />



---

## 알고리즘

### 정렬

선택정렬

<img src="md-images/image-20210117154358059.png" alt="image-20210117154358059" style="zoom: 33%;" />

<img src="md-images/image-20210117154434834.png" alt="image-20210117154434834" style="zoom:33%;" />

삽입정렬

![image-20210117154552981](md-images/image-20210117154552981.png)

![image-20210117154659665](md-images/image-20210117154659665.png)

퀵정렬

 ![image-20210117170420245](md-images/image-20210117170420245.png)

![image-20210117170500820](md-images/image-20210117170500820.png)

![image-20210118172402299](md-images/image-20210118172402299.png)

![image-20210118172332425](md-images/image-20210118172332425.png)

정렬 알고리즘 비교하기

![image-20210118172447123](md-images/image-20210118172447123.png)

### 탐색

이진탐색

![image-20210118203855677](md-images/image-20210118203855677.png)

![image-20210118205713090](md-images/image-20210118205713090.png)

![image-20210118213656874](md-images/image-20210118213656874.png)

값이 특정 번위에 속하는 데이터 개수를 파이썬 이진 탐색 라이브러리를 이용하여 구하기

![image-20210118213933405](md-images/image-20210118213933405.png)

파라메트릭 서치 -> 이진 탐색이용

떡볶이 문제

![image-20210118220232181](md-images/image-20210118220232181.png)

![image-20210118220253921](md-images/image-20210118220253921.png)

### 다이나믹 프로그래밍

피보나치 수열 - 재귀함수로 하면 시간이 오래걸림

![image-20210119143205104](md-images/image-20210119143205104.png)

![image-20210119143807959](md-images/image-20210119143807959.png)

![image-20210119144300297](md-images/image-20210119144300297.png)



### 아호 코라식 알고리즘

 **아호 코라식 알고리즘**(Aho–Corasick string matching algorithm)은 Alfred V. Aho와 Margaret J. Corasick이 고안한 [문자열 검색 알고리즘](https://ko.wikipedia.org/wiki/문자열_검색_알고리즘)(매칭 알고리즘)이다.



### Union-Find 자료구조

**Union-Find** 자료구조는 상호 배타적 집합, 서로소 집합 (Disjoint Set)을 표현하기 위한 자료구조이다.




### 외판원 순회(TSP: Traveling Salesperson Problem)

**외판원 순회(TSP: Traveling Salesperson Problem)**란 도시들이 있고 특정 도시에서 도시로 이동할 때 드는 비용이 주어졌을 때 불특정한 도시에서 출발해서 모든 도시를 돌고 다시 출발 도시로 돌아왔을 때 드는 최소 비용을 구하는 문제입니다.



---



## 안드로이드

---

- MVVM 패턴이란 무엇인가?
  모델, 뷰 , 뷰모델을 사용하고 요청을 받아 처리하는 부분과 보여주는 부분을 나누어 의존성을 낮추고 모듈화가 가능한 개발패턴입니다.

- 안드로이드 액티비티 생명주기

  onCreate - onStart - onResume - onPause - onStop - on Destroy

  ​                                                                                    ㄴonRestart - onStart

  

  ---

  프로젝트 관련 질문

  - 안드로이드 개발준비 : 스마트폰 개발자 옵션 활성화, USB디버깅 활성화, JDK설치, USB드라이버설치 등
  - 안드로이드 특징 : 오픈소스, 리눅스, 자바, ART라는 런타임이 탑재
    (ART : [안드로이드](https://namu.wiki/w/안드로이드(운영체제))에서 사용되던 기존의 [달빅](https://namu.wiki/w/달빅)VM의 한계점을 해결하기 위해서 [구글](https://namu.wiki/w/구글)에서 새로 개발한 런타임(실행환경))
  - DP를 사용해 다양한 디바이스 크기에 대응했다 글자는 SP사용

  

- Android 4 Component

- Activity : Base, UI / **UI화면을 담당한다**
- Service : Background Process / **백그라운드에서 실행되는 프로세스**
- Broadcast Receiver : (OS정보와 같은) Broadcast 내용을 받는다 / **안드로이드에서 다양한 이벤트와 정보를 받아 반응하는 컴포넌트**
- Content Provider :  **App Data 공유** (ex. 갤러리의 사진, 주소록의 전화번호를 가져온다, T전화기)



- 안드로이드 생명주기

<img src="md-images/image-20210107143710344.png" alt="image-20210107143710344" style="zoom:67%;" />

- intent의 역할 : 컴포넌트 간에 작업 수행을 위한 정보를 전달하는 역할 / 액티비티 간 화면전환, 서비스 시작, 브로드캐스트 전달 등에 사용
- SharedPreferences : 간단한 데이터를 파일로 저장
- Fragment : 하나의 액티비티에서 여러개의 화면을 갖고 싶을 때 사용한다

